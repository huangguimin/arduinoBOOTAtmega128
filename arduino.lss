
arduino.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  0001f830  000008c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000830  0001f000  0001f000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000010b  00800102  00800102  000008c6  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  000008c6  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000010a  00000000  00000000  000008e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000051c  00000000  00000000  000009f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000242  00000000  00000000  00000f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000889  00000000  00000000  0000114e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000b0  00000000  00000000  000019d8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000001ce  00000000  00000000  00001a88  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000489  00000000  00000000  00001c56  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000048  00000000  00000000  000020df  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0001f000 <__vectors>:
   1f000:	0c 94 46 f8 	jmp	0x1f08c	; 0x1f08c <__ctors_end>
   1f004:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f008:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f00c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f010:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f014:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f018:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f01c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f020:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f024:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f028:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f02c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f030:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f034:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f038:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f03c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f040:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f044:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f048:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f04c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f050:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f054:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f058:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f05c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f060:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f064:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f068:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f06c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f070:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f074:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f078:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f07c:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f080:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f084:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>
   1f088:	0c 94 65 f8 	jmp	0x1f0ca	; 0x1f0ca <__bad_interrupt>

0001f08c <__ctors_end>:
   1f08c:	11 24       	eor	r1, r1
   1f08e:	1f be       	out	0x3f, r1	; 63
   1f090:	cf ef       	ldi	r28, 0xFF	; 255
   1f092:	d0 e1       	ldi	r29, 0x10	; 16
   1f094:	de bf       	out	0x3e, r29	; 62
   1f096:	cd bf       	out	0x3d, r28	; 61

0001f098 <__do_copy_data>:
   1f098:	11 e0       	ldi	r17, 0x01	; 1
   1f09a:	a0 e0       	ldi	r26, 0x00	; 0
   1f09c:	b1 e0       	ldi	r27, 0x01	; 1
   1f09e:	e0 e3       	ldi	r30, 0x30	; 48
   1f0a0:	f8 ef       	ldi	r31, 0xF8	; 248
   1f0a2:	01 e0       	ldi	r16, 0x01	; 1
   1f0a4:	0b bf       	out	0x3b, r16	; 59
   1f0a6:	02 c0       	rjmp	.+4      	; 0x1f0ac <__do_copy_data+0x14>
   1f0a8:	07 90       	elpm	r0, Z+
   1f0aa:	0d 92       	st	X+, r0
   1f0ac:	a2 30       	cpi	r26, 0x02	; 2
   1f0ae:	b1 07       	cpc	r27, r17
   1f0b0:	d9 f7       	brne	.-10     	; 0x1f0a8 <__do_copy_data+0x10>

0001f0b2 <__do_clear_bss>:
   1f0b2:	12 e0       	ldi	r17, 0x02	; 2
   1f0b4:	a2 e0       	ldi	r26, 0x02	; 2
   1f0b6:	b1 e0       	ldi	r27, 0x01	; 1
   1f0b8:	01 c0       	rjmp	.+2      	; 0x1f0bc <.do_clear_bss_start>

0001f0ba <.do_clear_bss_loop>:
   1f0ba:	1d 92       	st	X+, r1

0001f0bc <.do_clear_bss_start>:
   1f0bc:	ad 30       	cpi	r26, 0x0D	; 13
   1f0be:	b1 07       	cpc	r27, r17
   1f0c0:	e1 f7       	brne	.-8      	; 0x1f0ba <.do_clear_bss_loop>
   1f0c2:	0e 94 5e f9 	call	0x1f2bc	; 0x1f2bc <main>
   1f0c6:	0c 94 16 fc 	jmp	0x1f82c	; 0x1f82c <_exit>

0001f0ca <__bad_interrupt>:
   1f0ca:	0c 94 00 f8 	jmp	0x1f000	; 0x1f000 <__vectors>

0001f0ce <putch>:
	putch(ch);
}


void putch(char ch)
{
   1f0ce:	98 2f       	mov	r25, r24
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
	if(bootuart == 1) {
   1f0d0:	80 91 02 01 	lds	r24, 0x0102
   1f0d4:	81 30       	cpi	r24, 0x01	; 1
   1f0d6:	21 f4       	brne	.+8      	; 0x1f0e0 <putch+0x12>
		while (!(UCSR0A & _BV(UDRE0)));
   1f0d8:	5d 9b       	sbis	0x0b, 5	; 11
   1f0da:	fe cf       	rjmp	.-4      	; 0x1f0d8 <putch+0xa>
		UDR0 = ch;
   1f0dc:	9c b9       	out	0x0c, r25	; 12
   1f0de:	08 95       	ret
	}
	else if (bootuart == 2) {
   1f0e0:	82 30       	cpi	r24, 0x02	; 2
   1f0e2:	31 f4       	brne	.+12     	; 0x1f0f0 <putch+0x22>
		while (!(UCSR1A & _BV(UDRE1)));
   1f0e4:	80 91 9b 00 	lds	r24, 0x009B
   1f0e8:	85 ff       	sbrs	r24, 5
   1f0ea:	fc cf       	rjmp	.-8      	; 0x1f0e4 <putch+0x16>
		UDR1 = ch;
   1f0ec:	90 93 9c 00 	sts	0x009C, r25
   1f0f0:	08 95       	ret

0001f0f2 <puthex>:
char gethex(void) {
	return (gethexnib() << 4) + gethexnib();
}


void puthex(char ch) {
   1f0f2:	1f 93       	push	r17
   1f0f4:	98 2f       	mov	r25, r24
	char ah;

	ah = ch >> 4;
   1f0f6:	82 95       	swap	r24
   1f0f8:	8f 70       	andi	r24, 0x0F	; 15
	if(ah >= 0x0a) {
   1f0fa:	8a 30       	cpi	r24, 0x0A	; 10
   1f0fc:	18 f0       	brcs	.+6      	; 0x1f104 <puthex+0x12>
		ah = ah - 0x0a + 'a';
   1f0fe:	28 2f       	mov	r18, r24
   1f100:	29 5a       	subi	r18, 0xA9	; 169
   1f102:	02 c0       	rjmp	.+4      	; 0x1f108 <puthex+0x16>
	} else {
		ah += '0';
   1f104:	28 2f       	mov	r18, r24
   1f106:	20 5d       	subi	r18, 0xD0	; 208
	}
	
	ch &= 0x0f;
   1f108:	89 2f       	mov	r24, r25
   1f10a:	8f 70       	andi	r24, 0x0F	; 15
	if(ch >= 0x0a) {
   1f10c:	8a 30       	cpi	r24, 0x0A	; 10
   1f10e:	18 f0       	brcs	.+6      	; 0x1f116 <puthex+0x24>
		ch = ch - 0x0a + 'a';
   1f110:	18 2f       	mov	r17, r24
   1f112:	19 5a       	subi	r17, 0xA9	; 169
   1f114:	02 c0       	rjmp	.+4      	; 0x1f11a <puthex+0x28>
	} else {
		ch += '0';
   1f116:	18 2f       	mov	r17, r24
   1f118:	10 5d       	subi	r17, 0xD0	; 208
	}
	
	putch(ah);
   1f11a:	82 2f       	mov	r24, r18
   1f11c:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
	putch(ch);
   1f120:	81 2f       	mov	r24, r17
   1f122:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
}
   1f126:	1f 91       	pop	r17
   1f128:	08 95       	ret

0001f12a <getch>:
#endif
}


char getch(void)
{
   1f12a:	ef 92       	push	r14
   1f12c:	ff 92       	push	r15
   1f12e:	0f 93       	push	r16
   1f130:	1f 93       	push	r17
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
	uint32_t count = 0;
	if(bootuart == 1) {
   1f132:	80 91 02 01 	lds	r24, 0x0102
   1f136:	81 30       	cpi	r24, 0x01	; 1
   1f138:	d9 f4       	brne	.+54     	; 0x1f170 <getch+0x46>
   1f13a:	ee 24       	eor	r14, r14
   1f13c:	ff 24       	eor	r15, r15
   1f13e:	87 01       	movw	r16, r14
   1f140:	13 c0       	rjmp	.+38     	; 0x1f168 <getch+0x3e>
		while(!(UCSR0A & _BV(RXC0))) {
			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
			/* HACKME:: here is a good place to count times*/
			count++;
   1f142:	08 94       	sec
   1f144:	e1 1c       	adc	r14, r1
   1f146:	f1 1c       	adc	r15, r1
   1f148:	01 1d       	adc	r16, r1
   1f14a:	11 1d       	adc	r17, r1
			if (count > MAX_TIME_COUNT)
   1f14c:	81 e4       	ldi	r24, 0x41	; 65
   1f14e:	e8 16       	cp	r14, r24
   1f150:	82 e4       	ldi	r24, 0x42	; 66
   1f152:	f8 06       	cpc	r15, r24
   1f154:	8f e0       	ldi	r24, 0x0F	; 15
   1f156:	08 07       	cpc	r16, r24
   1f158:	80 e0       	ldi	r24, 0x00	; 0
   1f15a:	18 07       	cpc	r17, r24
   1f15c:	28 f0       	brcs	.+10     	; 0x1f168 <getch+0x3e>
				app_start();
   1f15e:	e0 91 04 01 	lds	r30, 0x0104
   1f162:	f0 91 05 01 	lds	r31, 0x0105
   1f166:	09 95       	icall
char getch(void)
{
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
	uint32_t count = 0;
	if(bootuart == 1) {
		while(!(UCSR0A & _BV(RXC0))) {
   1f168:	5f 9b       	sbis	0x0b, 7	; 11
   1f16a:	eb cf       	rjmp	.-42     	; 0x1f142 <getch+0x18>
			count++;
			if (count > MAX_TIME_COUNT)
				app_start();
		}

		return UDR0;
   1f16c:	8c b1       	in	r24, 0x0c	; 12
   1f16e:	21 c0       	rjmp	.+66     	; 0x1f1b2 <getch+0x88>
	}
	else if(bootuart == 2) {
   1f170:	82 30       	cpi	r24, 0x02	; 2
   1f172:	11 f0       	breq	.+4      	; 0x1f178 <getch+0x4e>
   1f174:	80 e0       	ldi	r24, 0x00	; 0
   1f176:	1d c0       	rjmp	.+58     	; 0x1f1b2 <getch+0x88>
   1f178:	ee 24       	eor	r14, r14
   1f17a:	ff 24       	eor	r15, r15
   1f17c:	87 01       	movw	r16, r14
   1f17e:	13 c0       	rjmp	.+38     	; 0x1f1a6 <getch+0x7c>
		while(!(UCSR1A & _BV(RXC1))) {
			/* 20060803 DojoCorp:: Addon coming from the previous Bootloader*/               
			/* HACKME:: here is a good place to count times*/
			count++;
   1f180:	08 94       	sec
   1f182:	e1 1c       	adc	r14, r1
   1f184:	f1 1c       	adc	r15, r1
   1f186:	01 1d       	adc	r16, r1
   1f188:	11 1d       	adc	r17, r1
			if (count > MAX_TIME_COUNT)
   1f18a:	81 e4       	ldi	r24, 0x41	; 65
   1f18c:	e8 16       	cp	r14, r24
   1f18e:	82 e4       	ldi	r24, 0x42	; 66
   1f190:	f8 06       	cpc	r15, r24
   1f192:	8f e0       	ldi	r24, 0x0F	; 15
   1f194:	08 07       	cpc	r16, r24
   1f196:	80 e0       	ldi	r24, 0x00	; 0
   1f198:	18 07       	cpc	r17, r24
   1f19a:	28 f0       	brcs	.+10     	; 0x1f1a6 <getch+0x7c>
				app_start();
   1f19c:	e0 91 04 01 	lds	r30, 0x0104
   1f1a0:	f0 91 05 01 	lds	r31, 0x0105
   1f1a4:	09 95       	icall
		}

		return UDR0;
	}
	else if(bootuart == 2) {
		while(!(UCSR1A & _BV(RXC1))) {
   1f1a6:	80 91 9b 00 	lds	r24, 0x009B
   1f1aa:	87 ff       	sbrs	r24, 7
   1f1ac:	e9 cf       	rjmp	.-46     	; 0x1f180 <getch+0x56>
			count++;
			if (count > MAX_TIME_COUNT)
				app_start();
		}

		return UDR1;
   1f1ae:	80 91 9c 00 	lds	r24, 0x009C
		if (count > MAX_TIME_COUNT)
			app_start();
	}
	return UDR;
#endif
}
   1f1b2:	1f 91       	pop	r17
   1f1b4:	0f 91       	pop	r16
   1f1b6:	ff 90       	pop	r15
   1f1b8:	ef 90       	pop	r14
   1f1ba:	08 95       	ret

0001f1bc <gethexnib>:
	} /* end of forever loop */

}


char gethexnib(void) {
   1f1bc:	1f 93       	push	r17
	char a;
	a = getch(); putch(a);
   1f1be:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f1c2:	18 2f       	mov	r17, r24
   1f1c4:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
	if(a >= 'a') {
   1f1c8:	11 36       	cpi	r17, 0x61	; 97
   1f1ca:	10 f0       	brcs	.+4      	; 0x1f1d0 <gethexnib+0x14>
		return (a - 'a' + 0x0a);
   1f1cc:	17 55       	subi	r17, 0x57	; 87
   1f1ce:	03 c0       	rjmp	.+6      	; 0x1f1d6 <gethexnib+0x1a>
	} else if(a >= '0') {
   1f1d0:	10 33       	cpi	r17, 0x30	; 48
   1f1d2:	08 f0       	brcs	.+2      	; 0x1f1d6 <gethexnib+0x1a>
		return(a - '0');
   1f1d4:	10 53       	subi	r17, 0x30	; 48
	}
	return a;
}
   1f1d6:	81 2f       	mov	r24, r17
   1f1d8:	1f 91       	pop	r17
   1f1da:	08 95       	ret

0001f1dc <gethex>:


char gethex(void) {
   1f1dc:	1f 93       	push	r17
	return (gethexnib() << 4) + gethexnib();
   1f1de:	0e 94 de f8 	call	0x1f1bc	; 0x1f1bc <gethexnib>
   1f1e2:	18 2f       	mov	r17, r24
   1f1e4:	0e 94 de f8 	call	0x1f1bc	; 0x1f1bc <gethexnib>
   1f1e8:	12 95       	swap	r17
   1f1ea:	10 7f       	andi	r17, 0xF0	; 240
}
   1f1ec:	81 0f       	add	r24, r17
   1f1ee:	1f 91       	pop	r17
   1f1f0:	08 95       	ret

0001f1f2 <getNch>:
#endif
}


void getNch(uint8_t count)
{
   1f1f2:	98 2f       	mov	r25, r24
	while(count--) {
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
		if(bootuart == 1) {
   1f1f4:	20 91 02 01 	lds	r18, 0x0102
   1f1f8:	0f c0       	rjmp	.+30     	; 0x1f218 <getNch+0x26>
   1f1fa:	21 30       	cpi	r18, 0x01	; 1
   1f1fc:	21 f4       	brne	.+8      	; 0x1f206 <getNch+0x14>
			while(!(UCSR0A & _BV(RXC0)));
   1f1fe:	5f 9b       	sbis	0x0b, 7	; 11
   1f200:	fe cf       	rjmp	.-4      	; 0x1f1fe <getNch+0xc>
			UDR0;
   1f202:	8c b1       	in	r24, 0x0c	; 12
   1f204:	08 c0       	rjmp	.+16     	; 0x1f216 <getNch+0x24>
		} 
		else if(bootuart == 2) {
   1f206:	22 30       	cpi	r18, 0x02	; 2
   1f208:	31 f4       	brne	.+12     	; 0x1f216 <getNch+0x24>
			while(!(UCSR1A & _BV(RXC1)));
   1f20a:	80 91 9b 00 	lds	r24, 0x009B
   1f20e:	87 ff       	sbrs	r24, 7
   1f210:	fc cf       	rjmp	.-8      	; 0x1f20a <getNch+0x18>
			UDR1;
   1f212:	80 91 9c 00 	lds	r24, 0x009C
   1f216:	91 50       	subi	r25, 0x01	; 1
}


void getNch(uint8_t count)
{
	while(count--) {
   1f218:	99 23       	and	r25, r25
   1f21a:	79 f7       	brne	.-34     	; 0x1f1fa <getNch+0x8>
		//while(!(UCSRA & _BV(RXC)));
		//UDR;
		getch(); // need to handle time out
#endif		
	}
}
   1f21c:	08 95       	ret

0001f21e <byte_response>:


void byte_response(uint8_t val)
{
   1f21e:	1f 93       	push	r17
   1f220:	18 2f       	mov	r17, r24
	if (getch() == ' ') {
   1f222:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f226:	80 32       	cpi	r24, 0x20	; 32
   1f228:	51 f4       	brne	.+20     	; 0x1f23e <byte_response+0x20>
		putch(0x14);
   1f22a:	84 e1       	ldi	r24, 0x14	; 20
   1f22c:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
		putch(val);
   1f230:	81 2f       	mov	r24, r17
   1f232:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
		putch(0x10);
   1f236:	80 e1       	ldi	r24, 0x10	; 16
   1f238:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f23c:	0c c0       	rjmp	.+24     	; 0x1f256 <byte_response+0x38>
	} else {
		if (++error_count == MAX_ERROR_COUNT)
   1f23e:	80 91 03 01 	lds	r24, 0x0103
   1f242:	8f 5f       	subi	r24, 0xFF	; 255
   1f244:	80 93 03 01 	sts	0x0103, r24
   1f248:	85 30       	cpi	r24, 0x05	; 5
   1f24a:	29 f4       	brne	.+10     	; 0x1f256 <byte_response+0x38>
			app_start();
   1f24c:	e0 91 04 01 	lds	r30, 0x0104
   1f250:	f0 91 05 01 	lds	r31, 0x0105
   1f254:	09 95       	icall
	}
}
   1f256:	1f 91       	pop	r17
   1f258:	08 95       	ret

0001f25a <nothing_response>:


void nothing_response(void)
{
	if (getch() == ' ') {
   1f25a:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f25e:	80 32       	cpi	r24, 0x20	; 32
   1f260:	39 f4       	brne	.+14     	; 0x1f270 <nothing_response+0x16>
		putch(0x14);
   1f262:	84 e1       	ldi	r24, 0x14	; 20
   1f264:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
		putch(0x10);
   1f268:	80 e1       	ldi	r24, 0x10	; 16
   1f26a:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f26e:	08 95       	ret
	} else {
		if (++error_count == MAX_ERROR_COUNT)
   1f270:	80 91 03 01 	lds	r24, 0x0103
   1f274:	8f 5f       	subi	r24, 0xFF	; 255
   1f276:	80 93 03 01 	sts	0x0103, r24
   1f27a:	85 30       	cpi	r24, 0x05	; 5
   1f27c:	29 f4       	brne	.+10     	; 0x1f288 <nothing_response+0x2e>
			app_start();
   1f27e:	e0 91 04 01 	lds	r30, 0x0104
   1f282:	f0 91 05 01 	lds	r31, 0x0105
   1f286:	09 95       	icall
   1f288:	08 95       	ret

0001f28a <flash_led>:
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
   1f28a:	40 e9       	ldi	r20, 0x90	; 144
   1f28c:	51 e0       	ldi	r21, 0x01	; 1
   1f28e:	13 c0       	rjmp	.+38     	; 0x1f2b6 <flash_led+0x2c>
}

void flash_led(uint8_t count)
{
	while (count--) {
		LED_PORT |= _BV(LED);
   1f290:	c0 9a       	sbi	0x18, 0	; 24
   1f292:	28 ee       	ldi	r18, 0xE8	; 232
   1f294:	33 e0       	ldi	r19, 0x03	; 3
   1f296:	fa 01       	movw	r30, r20
   1f298:	31 97       	sbiw	r30, 0x01	; 1
   1f29a:	f1 f7       	brne	.-4      	; 0x1f298 <flash_led+0xe>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1f29c:	21 50       	subi	r18, 0x01	; 1
   1f29e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1f2a0:	d1 f7       	brne	.-12     	; 0x1f296 <flash_led+0xc>
		_delay_ms(100);
		LED_PORT &= ~_BV(LED);
   1f2a2:	c0 98       	cbi	0x18, 0	; 24
   1f2a4:	28 ee       	ldi	r18, 0xE8	; 232
   1f2a6:	33 e0       	ldi	r19, 0x03	; 3
   1f2a8:	fa 01       	movw	r30, r20
   1f2aa:	31 97       	sbiw	r30, 0x01	; 1
   1f2ac:	f1 f7       	brne	.-4      	; 0x1f2aa <flash_led+0x20>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
   1f2ae:	21 50       	subi	r18, 0x01	; 1
   1f2b0:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
   1f2b2:	d1 f7       	brne	.-12     	; 0x1f2a8 <flash_led+0x1e>
   1f2b4:	81 50       	subi	r24, 0x01	; 1
	}
}

void flash_led(uint8_t count)
{
	while (count--) {
   1f2b6:	88 23       	and	r24, r24
   1f2b8:	59 f7       	brne	.-42     	; 0x1f290 <flash_led+0x6>
		LED_PORT |= _BV(LED);
		_delay_ms(100);
		LED_PORT &= ~_BV(LED);
		_delay_ms(100);
	}
}
   1f2ba:	08 95       	ret

0001f2bc <main>:
void (*app_start)(void) = 0x0000;


/* main program starts here */
int main(void)
{
   1f2bc:	cf 92       	push	r12
   1f2be:	df 92       	push	r13
   1f2c0:	ef 92       	push	r14
   1f2c2:	ff 92       	push	r15
   1f2c4:	0f 93       	push	r16
   1f2c6:	1f 93       	push	r17
   1f2c8:	cf 93       	push	r28
   1f2ca:	df 93       	push	r29

	// Check if the WDT was used to reset, in which case we dont bootload and skip straight to the code. woot.
	if (! (ch &  _BV(EXTRF))) // if its a not an external reset...
		app_start();  // skip bootloader
#else
	asm volatile("nop\n\t");
   1f2cc:	00 00       	nop
#endif

	/* set pin direction for bootloader pin and enable pullup */
	/* for ATmega128, two pins need to be initialized */
#ifdef __AVR_ATmega128__
	BL_DDR &= ~_BV(BL0);
   1f2ce:	80 91 61 00 	lds	r24, 0x0061
   1f2d2:	8f 77       	andi	r24, 0x7F	; 127
   1f2d4:	80 93 61 00 	sts	0x0061, r24
	BL_DDR &= ~_BV(BL1);
   1f2d8:	80 91 61 00 	lds	r24, 0x0061
   1f2dc:	8f 7b       	andi	r24, 0xBF	; 191
   1f2de:	80 93 61 00 	sts	0x0061, r24
	BL_PORT |= _BV(BL0);
   1f2e2:	80 91 62 00 	lds	r24, 0x0062
   1f2e6:	80 68       	ori	r24, 0x80	; 128
   1f2e8:	80 93 62 00 	sts	0x0062, r24
	BL_PORT |= _BV(BL1);
   1f2ec:	80 91 62 00 	lds	r24, 0x0062
   1f2f0:	80 64       	ori	r24, 0x40	; 64
   1f2f2:	80 93 62 00 	sts	0x0062, r24


#ifdef __AVR_ATmega128__
	/* check which UART should be used for booting */
	//if(bit_is_clear(BL_PIN, BL0)) {
		bootuart = 1;
   1f2f6:	81 e0       	ldi	r24, 0x01	; 1
   1f2f8:	80 93 02 01 	sts	0x0102, r24


	/* initialize UART(s) depending on CPU defined */
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
	if(bootuart == 1) {
		UBRR0L = (uint8_t)(F_CPU/(BAUD_RATE*16L));
   1f2fc:	88 e0       	ldi	r24, 0x08	; 8
   1f2fe:	89 b9       	out	0x09, r24	; 9
		UBRR0H = (F_CPU/(BAUD_RATE*16L)-1) >> 8;
   1f300:	10 92 90 00 	sts	0x0090, r1
		UCSR0A = 0x00;
   1f304:	1b b8       	out	0x0b, r1	; 11
		UCSR0C = 0x06;
   1f306:	86 e0       	ldi	r24, 0x06	; 6
   1f308:	80 93 95 00 	sts	0x0095, r24
		UCSR0B = _BV(TXEN0)|_BV(RXEN0);
   1f30c:	88 e1       	ldi	r24, 0x18	; 24
   1f30e:	8a b9       	out	0x0a, r24	; 10
	PORTE |= _BV(PINE0);
#endif


	/* set LED pin as output */
	LED_DDR |= _BV(LED);
   1f310:	b8 9a       	sbi	0x17, 0	; 23


	/* flash onboard LED to signal entering of bootloader */
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
	// 4x for UART0, 5x for UART1
	flash_led(NUM_LED_FLASHES + bootuart);
   1f312:	82 e0       	ldi	r24, 0x02	; 2
   1f314:	0e 94 45 f9 	call	0x1f28a	; 0x1f28a <flash_led>
#endif
					address.word++;
				}			
			}
			else {					        //Write to FLASH one page at a time
				if (address.byte[1]>127) address_high = 0x01;	//Only possible with m128, m256 will need 3rd address byte. FIXME
   1f318:	ff 24       	eor	r15, r15
   1f31a:	f3 94       	inc	r15

	/* forever loop */
	for (;;) {

	/* get character from UART */
	ch = getch();
   1f31c:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>

	/* A bunch of if...else if... gives smaller code than switch...case ! */

	/* Hello is anyone home ? */ 
	if(ch=='0') {
   1f320:	80 33       	cpi	r24, 0x30	; 48
   1f322:	09 f4       	brne	.+2      	; 0x1f326 <main+0x6a>
   1f324:	40 c0       	rjmp	.+128    	; 0x1f3a6 <main+0xea>


	/* Request programmer ID */
	/* Not using PROGMEM string due to boot block in m128 being beyond 64kB boundry  */
	/* Would need to selectively manipulate RAMPZ, and it's only 9 characters anyway so who cares.  */
	else if(ch=='1') {
   1f326:	81 33       	cpi	r24, 0x31	; 49
   1f328:	e1 f4       	brne	.+56     	; 0x1f362 <main+0xa6>
		if (getch() == ' ') {
   1f32a:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f32e:	80 32       	cpi	r24, 0x20	; 32
   1f330:	09 f0       	breq	.+2      	; 0x1f334 <main+0x78>
   1f332:	59 c2       	rjmp	.+1202   	; 0x1f7e6 <block_done+0x248>
			putch(0x14);
   1f334:	84 e1       	ldi	r24, 0x14	; 20
   1f336:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('A');
   1f33a:	81 e4       	ldi	r24, 0x41	; 65
   1f33c:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('V');
   1f340:	86 e5       	ldi	r24, 0x56	; 86
   1f342:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('R');
   1f346:	82 e5       	ldi	r24, 0x52	; 82
   1f348:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch(' ');
   1f34c:	80 e2       	ldi	r24, 0x20	; 32
   1f34e:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('I');
   1f352:	89 e4       	ldi	r24, 0x49	; 73
   1f354:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('S');
   1f358:	83 e5       	ldi	r24, 0x53	; 83
   1f35a:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch('P');
   1f35e:	80 e5       	ldi	r24, 0x50	; 80
   1f360:	20 c1       	rjmp	.+576    	; 0x1f5a2 <block_done+0x4>
	}



	/* AVR ISP/STK500 board commands  DON'T CARE so default nothing_response */
	else if(ch=='@') {
   1f362:	80 34       	cpi	r24, 0x40	; 64
   1f364:	39 f4       	brne	.+14     	; 0x1f374 <main+0xb8>
		ch2 = getch();
   1f366:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
		if (ch2>0x85) getch();
   1f36a:	86 38       	cpi	r24, 0x86	; 134
   1f36c:	e0 f0       	brcs	.+56     	; 0x1f3a6 <main+0xea>
   1f36e:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f372:	19 c0       	rjmp	.+50     	; 0x1f3a6 <main+0xea>
		nothing_response();
	}


	/* AVR ISP/STK500 board requests */
	else if(ch=='A') {
   1f374:	81 34       	cpi	r24, 0x41	; 65
   1f376:	91 f4       	brne	.+36     	; 0x1f39c <main+0xe0>
		ch2 = getch();
   1f378:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
		if(ch2==0x80) byte_response(HW_VER);		// Hardware version
   1f37c:	80 38       	cpi	r24, 0x80	; 128
   1f37e:	09 f4       	brne	.+2      	; 0x1f382 <main+0xc6>
   1f380:	3f c0       	rjmp	.+126    	; 0x1f400 <main+0x144>
		else if(ch2==0x81) byte_response(SW_MAJOR);	// Software major version
   1f382:	81 38       	cpi	r24, 0x81	; 129
   1f384:	11 f4       	brne	.+4      	; 0x1f38a <main+0xce>
   1f386:	81 e0       	ldi	r24, 0x01	; 1
   1f388:	91 c1       	rjmp	.+802    	; 0x1f6ac <block_done+0x10e>
		else if(ch2==0x82) byte_response(SW_MINOR);	// Software minor version
   1f38a:	82 38       	cpi	r24, 0x82	; 130
   1f38c:	11 f4       	brne	.+4      	; 0x1f392 <main+0xd6>
   1f38e:	80 e1       	ldi	r24, 0x10	; 16
   1f390:	8d c1       	rjmp	.+794    	; 0x1f6ac <block_done+0x10e>
		else if(ch2==0x98) byte_response(0x03);		// Unknown but seems to be required by avr studio 3.56
   1f392:	88 39       	cpi	r24, 0x98	; 152
   1f394:	09 f0       	breq	.+2      	; 0x1f398 <main+0xdc>
   1f396:	89 c1       	rjmp	.+786    	; 0x1f6aa <block_done+0x10c>
   1f398:	83 e0       	ldi	r24, 0x03	; 3
   1f39a:	88 c1       	rjmp	.+784    	; 0x1f6ac <block_done+0x10e>
		else byte_response(0x00);				// Covers various unnecessary responses we don't care about
	}


	/* Device Parameters  DON'T CARE, DEVICE IS FIXED  */
	else if(ch=='B') {
   1f39c:	82 34       	cpi	r24, 0x42	; 66
   1f39e:	31 f4       	brne	.+12     	; 0x1f3ac <main+0xf0>
		getNch(20);
   1f3a0:	84 e1       	ldi	r24, 0x14	; 20
   1f3a2:	0e 94 f9 f8 	call	0x1f1f2	; 0x1f1f2 <getNch>
		nothing_response();
   1f3a6:	0e 94 2d f9 	call	0x1f25a	; 0x1f25a <nothing_response>
   1f3aa:	b8 cf       	rjmp	.-144    	; 0x1f31c <main+0x60>
	}


	/* Parallel programming stuff  DON'T CARE  */
	else if(ch=='E') {
   1f3ac:	85 34       	cpi	r24, 0x45	; 69
   1f3ae:	11 f4       	brne	.+4      	; 0x1f3b4 <main+0xf8>
		getNch(5);
   1f3b0:	85 e0       	ldi	r24, 0x05	; 5
   1f3b2:	f7 cf       	rjmp	.-18     	; 0x1f3a2 <main+0xe6>
	}


	/* P: Enter programming mode  */
	/* R: Erase device, don't care as we will erase one page at a time anyway.  */
	else if(ch=='P' || ch=='R') {
   1f3b4:	80 35       	cpi	r24, 0x50	; 80
   1f3b6:	b9 f3       	breq	.-18     	; 0x1f3a6 <main+0xea>
   1f3b8:	82 35       	cpi	r24, 0x52	; 82
   1f3ba:	a9 f3       	breq	.-22     	; 0x1f3a6 <main+0xea>
		nothing_response();
	}


	/* Leave programming mode  */
	else if(ch=='Q') {
   1f3bc:	81 35       	cpi	r24, 0x51	; 81
   1f3be:	99 f3       	breq	.-26     	; 0x1f3a6 <main+0xea>


	/* Set address, little endian. EEPROM in bytes, FLASH in words  */
	/* Perhaps extra address bytes may be added in future to support > 128kB FLASH.  */
	/* This might explain why little endian was used here, big endian used everywhere else.  */
	else if(ch=='U') {
   1f3c0:	85 35       	cpi	r24, 0x55	; 85
   1f3c2:	49 f4       	brne	.+18     	; 0x1f3d6 <main+0x11a>
		address.byte[0] = getch();
   1f3c4:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f3c8:	80 93 06 01 	sts	0x0106, r24
		address.byte[1] = getch();
   1f3cc:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f3d0:	80 93 07 01 	sts	0x0107, r24
   1f3d4:	e8 cf       	rjmp	.-48     	; 0x1f3a6 <main+0xea>
		nothing_response();
	}


	/* Universal SPI programming command, disabled.  Would be used for fuses and lock bits.  */
	else if(ch=='V') {
   1f3d6:	86 35       	cpi	r24, 0x56	; 86
   1f3d8:	c9 f4       	brne	.+50     	; 0x1f40c <main+0x150>
		if (getch() == 0x30) {
   1f3da:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f3de:	80 33       	cpi	r24, 0x30	; 48
   1f3e0:	89 f4       	brne	.+34     	; 0x1f404 <main+0x148>
			getch();
   1f3e2:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
			ch = getch();
   1f3e6:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f3ea:	18 2f       	mov	r17, r24
			getch();
   1f3ec:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
			if (ch == 0) {
   1f3f0:	11 23       	and	r17, r17
   1f3f2:	11 f4       	brne	.+4      	; 0x1f3f8 <main+0x13c>
				byte_response(SIG1);
   1f3f4:	8e e1       	ldi	r24, 0x1E	; 30
   1f3f6:	5a c1       	rjmp	.+692    	; 0x1f6ac <block_done+0x10e>
			} else if (ch == 1) {
   1f3f8:	11 30       	cpi	r17, 0x01	; 1
   1f3fa:	11 f4       	brne	.+4      	; 0x1f400 <main+0x144>
				byte_response(SIG2); 
   1f3fc:	87 e9       	ldi	r24, 0x97	; 151
   1f3fe:	56 c1       	rjmp	.+684    	; 0x1f6ac <block_done+0x10e>
			} else {
				byte_response(SIG3);
   1f400:	82 e0       	ldi	r24, 0x02	; 2
   1f402:	54 c1       	rjmp	.+680    	; 0x1f6ac <block_done+0x10e>
			} 
		} else {
			getNch(3);
   1f404:	83 e0       	ldi	r24, 0x03	; 3
   1f406:	0e 94 f9 f8 	call	0x1f1f2	; 0x1f1f2 <getNch>
   1f40a:	4f c1       	rjmp	.+670    	; 0x1f6aa <block_done+0x10c>
		}
	}


	/* Write memory, length is big endian and is in bytes  */
	else if(ch=='d') {
   1f40c:	84 36       	cpi	r24, 0x64	; 100
   1f40e:	09 f0       	breq	.+2      	; 0x1f412 <main+0x156>
   1f410:	ce c0       	rjmp	.+412    	; 0x1f5ae <block_done+0x10>
		length.byte[1] = getch();
   1f412:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f416:	80 93 09 02 	sts	0x0209, r24
		length.byte[0] = getch();
   1f41a:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f41e:	80 93 08 02 	sts	0x0208, r24
		flags.eeprom = 0;
   1f422:	80 91 0c 02 	lds	r24, 0x020C
   1f426:	8e 7f       	andi	r24, 0xFE	; 254
   1f428:	80 93 0c 02 	sts	0x020C, r24
		if (getch() == 'E') flags.eeprom = 1;
   1f42c:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f430:	85 34       	cpi	r24, 0x45	; 69
   1f432:	29 f4       	brne	.+10     	; 0x1f43e <main+0x182>
   1f434:	80 91 0c 02 	lds	r24, 0x020C
   1f438:	81 60       	ori	r24, 0x01	; 1
   1f43a:	80 93 0c 02 	sts	0x020C, r24
   1f43e:	00 e0       	ldi	r16, 0x00	; 0
   1f440:	10 e0       	ldi	r17, 0x00	; 0
   1f442:	08 c0       	rjmp	.+16     	; 0x1f454 <main+0x198>
		for (w=0;w<length.word;w++) {
			buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
   1f444:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f448:	f8 01       	movw	r30, r16
   1f44a:	e8 5f       	subi	r30, 0xF8	; 248
   1f44c:	fe 4f       	sbci	r31, 0xFE	; 254
   1f44e:	80 83       	st	Z, r24
	else if(ch=='d') {
		length.byte[1] = getch();
		length.byte[0] = getch();
		flags.eeprom = 0;
		if (getch() == 'E') flags.eeprom = 1;
		for (w=0;w<length.word;w++) {
   1f450:	0f 5f       	subi	r16, 0xFF	; 255
   1f452:	1f 4f       	sbci	r17, 0xFF	; 255
   1f454:	80 91 08 02 	lds	r24, 0x0208
   1f458:	90 91 09 02 	lds	r25, 0x0209
   1f45c:	08 17       	cp	r16, r24
   1f45e:	19 07       	cpc	r17, r25
   1f460:	88 f3       	brcs	.-30     	; 0x1f444 <main+0x188>
			buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
		}
		if (getch() == ' ') {
   1f462:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f466:	80 32       	cpi	r24, 0x20	; 32
   1f468:	09 f0       	breq	.+2      	; 0x1f46c <main+0x1b0>
   1f46a:	bd c1       	rjmp	.+890    	; 0x1f7e6 <block_done+0x248>
			if (flags.eeprom) {		                //Write to EEPROM one byte at a time
   1f46c:	80 91 0c 02 	lds	r24, 0x020C
   1f470:	80 ff       	sbrs	r24, 0
   1f472:	2a c0       	rjmp	.+84     	; 0x1f4c8 <main+0x20c>
				address.word <<= 1;
   1f474:	80 91 06 01 	lds	r24, 0x0106
   1f478:	90 91 07 01 	lds	r25, 0x0107
   1f47c:	88 0f       	add	r24, r24
   1f47e:	99 1f       	adc	r25, r25
   1f480:	90 93 07 01 	sts	0x0107, r25
   1f484:	80 93 06 01 	sts	0x0106, r24
   1f488:	00 e0       	ldi	r16, 0x00	; 0
   1f48a:	10 e0       	ldi	r17, 0x00	; 0
   1f48c:	15 c0       	rjmp	.+42     	; 0x1f4b8 <main+0x1fc>
					EEAR = (uint16_t)(void *)address.word;
					EEDR = buff[w];
					EECR |= (1<<EEMPE);
					EECR |= (1<<EEPE);
#else
					eeprom_write_byte((void *)address.word,buff[w]);
   1f48e:	f8 01       	movw	r30, r16
   1f490:	e8 5f       	subi	r30, 0xF8	; 248
   1f492:	fe 4f       	sbci	r31, 0xFE	; 254
   1f494:	80 91 06 01 	lds	r24, 0x0106
   1f498:	90 91 07 01 	lds	r25, 0x0107
   1f49c:	60 81       	ld	r22, Z
   1f49e:	0e 94 09 fc 	call	0x1f812	; 0x1f812 <__eewr_byte_m128>
#endif
					address.word++;
   1f4a2:	80 91 06 01 	lds	r24, 0x0106
   1f4a6:	90 91 07 01 	lds	r25, 0x0107
   1f4aa:	01 96       	adiw	r24, 0x01	; 1
   1f4ac:	90 93 07 01 	sts	0x0107, r25
   1f4b0:	80 93 06 01 	sts	0x0106, r24
			buff[w] = getch();	                        // Store data in buffer, can't keep up with serial data stream whilst programming pages
		}
		if (getch() == ' ') {
			if (flags.eeprom) {		                //Write to EEPROM one byte at a time
				address.word <<= 1;
				for(w=0;w<length.word;w++) {
   1f4b4:	0f 5f       	subi	r16, 0xFF	; 255
   1f4b6:	1f 4f       	sbci	r17, 0xFF	; 255
   1f4b8:	80 91 08 02 	lds	r24, 0x0208
   1f4bc:	90 91 09 02 	lds	r25, 0x0209
   1f4c0:	08 17       	cp	r16, r24
   1f4c2:	19 07       	cpc	r17, r25
   1f4c4:	20 f3       	brcs	.-56     	; 0x1f48e <main+0x1d2>
   1f4c6:	6c c0       	rjmp	.+216    	; 0x1f5a0 <block_done+0x2>
#endif
					address.word++;
				}			
			}
			else {					        //Write to FLASH one page at a time
				if (address.byte[1]>127) address_high = 0x01;	//Only possible with m128, m256 will need 3rd address byte. FIXME
   1f4c8:	80 91 07 01 	lds	r24, 0x0107
   1f4cc:	88 23       	and	r24, r24
   1f4ce:	88 0f       	add	r24, r24
   1f4d0:	88 0b       	sbc	r24, r24
   1f4d2:	8f 21       	and	r24, r15
   1f4d4:	80 93 0b 02 	sts	0x020B, r24
				else address_high = 0x00;
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__)
				RAMPZ = address_high;
   1f4d8:	8b bf       	out	0x3b, r24	; 59
#endif
				address.word = address.word << 1;	        //address * 2 -> byte location
   1f4da:	80 91 06 01 	lds	r24, 0x0106
   1f4de:	90 91 07 01 	lds	r25, 0x0107
   1f4e2:	88 0f       	add	r24, r24
   1f4e4:	99 1f       	adc	r25, r25
   1f4e6:	90 93 07 01 	sts	0x0107, r25
   1f4ea:	80 93 06 01 	sts	0x0106, r24
				/* if ((length.byte[0] & 0x01) == 0x01) length.word++;	//Even up an odd number of bytes */
				if ((length.byte[0] & 0x01)) length.word++;	//Even up an odd number of bytes
   1f4ee:	80 91 08 02 	lds	r24, 0x0208
   1f4f2:	80 ff       	sbrs	r24, 0
   1f4f4:	09 c0       	rjmp	.+18     	; 0x1f508 <main+0x24c>
   1f4f6:	80 91 08 02 	lds	r24, 0x0208
   1f4fa:	90 91 09 02 	lds	r25, 0x0209
   1f4fe:	01 96       	adiw	r24, 0x01	; 1
   1f500:	90 93 09 02 	sts	0x0209, r25
   1f504:	80 93 08 02 	sts	0x0208, r24
				cli();					//Disable interrupts, just to be sure
   1f508:	f8 94       	cli
#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega1281__)
				while(bit_is_set(EECR,EEPE));			//Wait for previous EEPROM writes to complete
#else
				while(bit_is_set(EECR,EEWE));			//Wait for previous EEPROM writes to complete
   1f50a:	e1 99       	sbic	0x1c, 1	; 28
   1f50c:	fe cf       	rjmp	.-4      	; 0x1f50a <main+0x24e>
#endif
				asm volatile(
   1f50e:	11 27       	eor	r17, r17
   1f510:	e0 91 06 01 	lds	r30, 0x0106
   1f514:	f0 91 07 01 	lds	r31, 0x0107
   1f518:	c8 e0       	ldi	r28, 0x08	; 8
   1f51a:	d1 e0       	ldi	r29, 0x01	; 1
   1f51c:	80 91 08 02 	lds	r24, 0x0208
   1f520:	90 91 09 02 	lds	r25, 0x0209

0001f524 <length_loop>:
   1f524:	10 30       	cpi	r17, 0x00	; 0
   1f526:	91 f4       	brne	.+36     	; 0x1f54c <no_page_erase>

0001f528 <wait_spm1>:
   1f528:	00 91 68 00 	lds	r16, 0x0068
   1f52c:	01 70       	andi	r16, 0x01	; 1
   1f52e:	01 30       	cpi	r16, 0x01	; 1
   1f530:	d9 f3       	breq	.-10     	; 0x1f528 <wait_spm1>
   1f532:	03 e0       	ldi	r16, 0x03	; 3
   1f534:	00 93 68 00 	sts	0x0068, r16
   1f538:	e8 95       	spm

0001f53a <wait_spm2>:
   1f53a:	00 91 68 00 	lds	r16, 0x0068
   1f53e:	01 70       	andi	r16, 0x01	; 1
   1f540:	01 30       	cpi	r16, 0x01	; 1
   1f542:	d9 f3       	breq	.-10     	; 0x1f53a <wait_spm2>
   1f544:	01 e1       	ldi	r16, 0x11	; 17
   1f546:	00 93 68 00 	sts	0x0068, r16
   1f54a:	e8 95       	spm

0001f54c <no_page_erase>:
   1f54c:	09 90       	ld	r0, Y+
   1f54e:	19 90       	ld	r1, Y+

0001f550 <wait_spm3>:
   1f550:	00 91 68 00 	lds	r16, 0x0068
   1f554:	01 70       	andi	r16, 0x01	; 1
   1f556:	01 30       	cpi	r16, 0x01	; 1
   1f558:	d9 f3       	breq	.-10     	; 0x1f550 <wait_spm3>
   1f55a:	01 e0       	ldi	r16, 0x01	; 1
   1f55c:	00 93 68 00 	sts	0x0068, r16
   1f560:	e8 95       	spm
   1f562:	13 95       	inc	r17
   1f564:	10 38       	cpi	r17, 0x80	; 128
   1f566:	98 f0       	brcs	.+38     	; 0x1f58e <same_page>

0001f568 <write_page>:
   1f568:	11 27       	eor	r17, r17

0001f56a <wait_spm4>:
   1f56a:	00 91 68 00 	lds	r16, 0x0068
   1f56e:	01 70       	andi	r16, 0x01	; 1
   1f570:	01 30       	cpi	r16, 0x01	; 1
   1f572:	d9 f3       	breq	.-10     	; 0x1f56a <wait_spm4>
   1f574:	05 e0       	ldi	r16, 0x05	; 5
   1f576:	00 93 68 00 	sts	0x0068, r16
   1f57a:	e8 95       	spm

0001f57c <wait_spm5>:
   1f57c:	00 91 68 00 	lds	r16, 0x0068
   1f580:	01 70       	andi	r16, 0x01	; 1
   1f582:	01 30       	cpi	r16, 0x01	; 1
   1f584:	d9 f3       	breq	.-10     	; 0x1f57c <wait_spm5>
   1f586:	01 e1       	ldi	r16, 0x11	; 17
   1f588:	00 93 68 00 	sts	0x0068, r16
   1f58c:	e8 95       	spm

0001f58e <same_page>:
   1f58e:	32 96       	adiw	r30, 0x02	; 2
   1f590:	02 97       	sbiw	r24, 0x02	; 2
   1f592:	09 f0       	breq	.+2      	; 0x1f596 <final_write>
   1f594:	c7 cf       	rjmp	.-114    	; 0x1f524 <length_loop>

0001f596 <final_write>:
   1f596:	10 30       	cpi	r17, 0x00	; 0
   1f598:	11 f0       	breq	.+4      	; 0x1f59e <block_done>
   1f59a:	02 96       	adiw	r24, 0x02	; 2
   1f59c:	e5 cf       	rjmp	.-54     	; 0x1f568 <write_page>

0001f59e <block_done>:
   1f59e:	11 24       	eor	r1, r1
#endif
					 );
				/* Should really add a wait for RWW section to be enabled, don't actually need it since we never */
				/* exit the bootloader without a power cycle anyhow */
			}
			putch(0x14);
   1f5a0:	84 e1       	ldi	r24, 0x14	; 20
   1f5a2:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch(0x10);
   1f5a6:	80 e1       	ldi	r24, 0x10	; 16
   1f5a8:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f5ac:	b7 ce       	rjmp	.-658    	; 0x1f31c <main+0x60>
		}		
	}


	/* Read memory block mode, length is big endian.  */
	else if(ch=='t') {
   1f5ae:	84 37       	cpi	r24, 0x74	; 116
   1f5b0:	09 f0       	breq	.+2      	; 0x1f5b4 <block_done+0x16>
   1f5b2:	67 c0       	rjmp	.+206    	; 0x1f682 <block_done+0xe4>
		length.byte[1] = getch();
   1f5b4:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f5b8:	80 93 09 02 	sts	0x0209, r24
		length.byte[0] = getch();
   1f5bc:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f5c0:	80 93 08 02 	sts	0x0208, r24
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
		if (address.word>0x7FFF) flags.rampz = 1;		// No go with m256, FIXME
   1f5c4:	80 91 06 01 	lds	r24, 0x0106
   1f5c8:	90 91 07 01 	lds	r25, 0x0107
   1f5cc:	20 91 0c 02 	lds	r18, 0x020C
   1f5d0:	97 ff       	sbrs	r25, 7
   1f5d2:	02 c0       	rjmp	.+4      	; 0x1f5d8 <block_done+0x3a>
   1f5d4:	22 60       	ori	r18, 0x02	; 2
   1f5d6:	01 c0       	rjmp	.+2      	; 0x1f5da <block_done+0x3c>
		else flags.rampz = 0;
   1f5d8:	2d 7f       	andi	r18, 0xFD	; 253
   1f5da:	20 93 0c 02 	sts	0x020C, r18
#endif
		address.word = address.word << 1;	        // address * 2 -> byte location
   1f5de:	80 91 06 01 	lds	r24, 0x0106
   1f5e2:	90 91 07 01 	lds	r25, 0x0107
   1f5e6:	88 0f       	add	r24, r24
   1f5e8:	99 1f       	adc	r25, r25
   1f5ea:	90 93 07 01 	sts	0x0107, r25
   1f5ee:	80 93 06 01 	sts	0x0106, r24
		if (getch() == 'E') flags.eeprom = 1;
   1f5f2:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f5f6:	20 91 0c 02 	lds	r18, 0x020C
   1f5fa:	85 34       	cpi	r24, 0x45	; 69
   1f5fc:	11 f4       	brne	.+4      	; 0x1f602 <block_done+0x64>
   1f5fe:	21 60       	ori	r18, 0x01	; 1
   1f600:	01 c0       	rjmp	.+2      	; 0x1f604 <block_done+0x66>
		else flags.eeprom = 0;
   1f602:	2e 7f       	andi	r18, 0xFE	; 254
   1f604:	20 93 0c 02 	sts	0x020C, r18
		if (getch() == ' ') {		                // Command terminator
   1f608:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f60c:	80 32       	cpi	r24, 0x20	; 32
   1f60e:	09 f0       	breq	.+2      	; 0x1f612 <block_done+0x74>
   1f610:	85 ce       	rjmp	.-758    	; 0x1f31c <main+0x60>
			putch(0x14);
   1f612:	84 e1       	ldi	r24, 0x14	; 20
   1f614:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f618:	00 e0       	ldi	r16, 0x00	; 0
   1f61a:	10 e0       	ldi	r17, 0x00	; 0
   1f61c:	2a c0       	rjmp	.+84     	; 0x1f672 <block_done+0xd4>
			for (w=0;w < length.word;w++) {		        // Can handle odd and even lengths okay
				if (flags.eeprom) {	                        // Byte access EEPROM read
   1f61e:	80 91 0c 02 	lds	r24, 0x020C
   1f622:	80 ff       	sbrs	r24, 0
   1f624:	07 c0       	rjmp	.+14     	; 0x1f634 <block_done+0x96>
					while(EECR & (1<<EEPE));
					EEAR = (uint16_t)(void *)address.word;
					EECR |= (1<<EERE);
					putch(EEDR);
#else
					putch(eeprom_read_byte((void *)address.word));
   1f626:	80 91 06 01 	lds	r24, 0x0106
   1f62a:	90 91 07 01 	lds	r25, 0x0107
   1f62e:	0e 94 01 fc 	call	0x1f802	; 0x1f802 <__eerd_byte_m128>
   1f632:	12 c0       	rjmp	.+36     	; 0x1f658 <block_done+0xba>
   1f634:	e0 91 06 01 	lds	r30, 0x0106
   1f638:	f0 91 07 01 	lds	r31, 0x0107
#endif
					address.word++;
				}
				else {

					if (!flags.rampz) putch(pgm_read_byte_near(address.word));
   1f63c:	81 fd       	sbrc	r24, 1
   1f63e:	02 c0       	rjmp	.+4      	; 0x1f644 <block_done+0xa6>
   1f640:	84 91       	lpm	r24, Z+
   1f642:	0a c0       	rjmp	.+20     	; 0x1f658 <block_done+0xba>
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
					else putch(pgm_read_byte_far(address.word + 0x10000));
   1f644:	cf 01       	movw	r24, r30
   1f646:	a0 e0       	ldi	r26, 0x00	; 0
   1f648:	b0 e0       	ldi	r27, 0x00	; 0
   1f64a:	80 50       	subi	r24, 0x00	; 0
   1f64c:	90 40       	sbci	r25, 0x00	; 0
   1f64e:	af 4f       	sbci	r26, 0xFF	; 255
   1f650:	bf 4f       	sbci	r27, 0xFF	; 255
   1f652:	ab bf       	out	0x3b, r26	; 59
   1f654:	fc 01       	movw	r30, r24
   1f656:	87 91       	elpm	r24, Z+
   1f658:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					// Hmmmm, yuck  FIXME when m256 arrvies
#endif
					address.word++;
   1f65c:	80 91 06 01 	lds	r24, 0x0106
   1f660:	90 91 07 01 	lds	r25, 0x0107
   1f664:	01 96       	adiw	r24, 0x01	; 1
   1f666:	90 93 07 01 	sts	0x0107, r25
   1f66a:	80 93 06 01 	sts	0x0106, r24
		address.word = address.word << 1;	        // address * 2 -> byte location
		if (getch() == 'E') flags.eeprom = 1;
		else flags.eeprom = 0;
		if (getch() == ' ') {		                // Command terminator
			putch(0x14);
			for (w=0;w < length.word;w++) {		        // Can handle odd and even lengths okay
   1f66e:	0f 5f       	subi	r16, 0xFF	; 255
   1f670:	1f 4f       	sbci	r17, 0xFF	; 255
   1f672:	80 91 08 02 	lds	r24, 0x0208
   1f676:	90 91 09 02 	lds	r25, 0x0209
   1f67a:	08 17       	cp	r16, r24
   1f67c:	19 07       	cpc	r17, r25
   1f67e:	78 f2       	brcs	.-98     	; 0x1f61e <block_done+0x80>
   1f680:	92 cf       	rjmp	.-220    	; 0x1f5a6 <block_done+0x8>
		}
	}


	/* Get device signature bytes  */
	else if(ch=='u') {
   1f682:	85 37       	cpi	r24, 0x75	; 117
   1f684:	81 f4       	brne	.+32     	; 0x1f6a6 <block_done+0x108>
		if (getch() == ' ') {
   1f686:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f68a:	80 32       	cpi	r24, 0x20	; 32
   1f68c:	09 f0       	breq	.+2      	; 0x1f690 <block_done+0xf2>
   1f68e:	ab c0       	rjmp	.+342    	; 0x1f7e6 <block_done+0x248>
			putch(0x14);
   1f690:	84 e1       	ldi	r24, 0x14	; 20
   1f692:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch(SIG1);
   1f696:	8e e1       	ldi	r24, 0x1E	; 30
   1f698:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch(SIG2);
   1f69c:	87 e9       	ldi	r24, 0x97	; 151
   1f69e:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			putch(SIG3);
   1f6a2:	82 e0       	ldi	r24, 0x02	; 2
   1f6a4:	7e cf       	rjmp	.-260    	; 0x1f5a2 <block_done+0x4>
		}
	}


	/* Read oscillator calibration byte */
	else if(ch=='v') {
   1f6a6:	86 37       	cpi	r24, 0x76	; 118
   1f6a8:	21 f4       	brne	.+8      	; 0x1f6b2 <block_done+0x114>
		byte_response(0x00);
   1f6aa:	80 e0       	ldi	r24, 0x00	; 0
   1f6ac:	0e 94 0f f9 	call	0x1f21e	; 0x1f21e <byte_response>
   1f6b0:	35 ce       	rjmp	.-918    	; 0x1f31c <main+0x60>
#if defined MONITOR 

	/* here come the extended monitor commands by Erik Lins */

	/* check for three times exclamation mark pressed */
	else if(ch=='!') {
   1f6b2:	81 32       	cpi	r24, 0x21	; 33
   1f6b4:	09 f0       	breq	.+2      	; 0x1f6b8 <block_done+0x11a>
   1f6b6:	97 c0       	rjmp	.+302    	; 0x1f7e6 <block_done+0x248>
		ch = getch();
   1f6b8:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
		if(ch=='!') {
   1f6bc:	81 32       	cpi	r24, 0x21	; 33
   1f6be:	09 f0       	breq	.+2      	; 0x1f6c2 <block_done+0x124>
   1f6c0:	2d ce       	rjmp	.-934    	; 0x1f31c <main+0x60>
		ch = getch();
   1f6c2:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
		if(ch=='!') {
   1f6c6:	81 32       	cpi	r24, 0x21	; 33
   1f6c8:	09 f0       	breq	.+2      	; 0x1f6cc <block_done+0x12e>
   1f6ca:	28 ce       	rjmp	.-944    	; 0x1f31c <main+0x60>
#elif defined __AVR_ATmega1280__ 
			welcome = "ATmegaBOOT / Arduino Mega - (C) Arduino LLC - 090930\n\r";
#endif

			/* turn on LED */
			LED_DDR |= _BV(LED);
   1f6cc:	b8 9a       	sbi	0x17, 0	; 23
			LED_PORT &= ~_BV(LED);
   1f6ce:	c0 98       	cbi	0x18, 0	; 24

			/* print a welcome message and command overview */
			for(i=0; welcome[i] != '\0'; ++i) {
   1f6d0:	10 92 0a 02 	sts	0x020A, r1
   1f6d4:	07 c0       	rjmp	.+14     	; 0x1f6e4 <block_done+0x146>
				putch(welcome[i]);
   1f6d6:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
			/* turn on LED */
			LED_DDR |= _BV(LED);
			LED_PORT &= ~_BV(LED);

			/* print a welcome message and command overview */
			for(i=0; welcome[i] != '\0'; ++i) {
   1f6da:	80 91 0a 02 	lds	r24, 0x020A
   1f6de:	8f 5f       	subi	r24, 0xFF	; 255
   1f6e0:	80 93 0a 02 	sts	0x020A, r24
   1f6e4:	e0 91 0a 02 	lds	r30, 0x020A
   1f6e8:	f0 e0       	ldi	r31, 0x00	; 0
   1f6ea:	e0 50       	subi	r30, 0x00	; 0
   1f6ec:	ff 4f       	sbci	r31, 0xFF	; 255
   1f6ee:	80 81       	ld	r24, Z
   1f6f0:	88 23       	and	r24, r24
   1f6f2:	89 f7       	brne	.-30     	; 0x1f6d6 <block_done+0x138>
				putch(welcome[i]);
			}

			/* test for valid commands */
			for(;;) {
				putch('\n');
   1f6f4:	8a e0       	ldi	r24, 0x0A	; 10
   1f6f6:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
				putch('\r');
   1f6fa:	8d e0       	ldi	r24, 0x0D	; 13
   1f6fc:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
				putch(':');
   1f700:	8a e3       	ldi	r24, 0x3A	; 58
   1f702:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
				putch(' ');
   1f706:	80 e2       	ldi	r24, 0x20	; 32
   1f708:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>

				ch = getch();
   1f70c:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f710:	18 2f       	mov	r17, r24
				putch(ch);
   1f712:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>

				/* toggle LED */
				if(ch == 't') {
   1f716:	14 37       	cpi	r17, 0x74	; 116
   1f718:	51 f4       	brne	.+20     	; 0x1f72e <block_done+0x190>
					if(bit_is_set(LED_PIN,LED)) {
   1f71a:	b0 9b       	sbis	0x16, 0	; 22
   1f71c:	03 c0       	rjmp	.+6      	; 0x1f724 <block_done+0x186>
						LED_PORT &= ~_BV(LED);
   1f71e:	c0 98       	cbi	0x18, 0	; 24
						putch('1');
   1f720:	81 e3       	ldi	r24, 0x31	; 49
   1f722:	02 c0       	rjmp	.+4      	; 0x1f728 <block_done+0x18a>
					} else {
						LED_PORT |= _BV(LED);
   1f724:	c0 9a       	sbi	0x18, 0	; 24
						putch('0');
   1f726:	80 e3       	ldi	r24, 0x30	; 48
   1f728:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f72c:	e3 cf       	rjmp	.-58     	; 0x1f6f4 <block_done+0x156>
					}
				} 

				/* read byte from address */
				else if(ch == 'r') {
   1f72e:	12 37       	cpi	r17, 0x72	; 114
   1f730:	b1 f4       	brne	.+44     	; 0x1f75e <block_done+0x1c0>
					ch = getch(); putch(ch);
   1f732:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f736:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					addrh = gethex();
   1f73a:	0e 94 ee f8 	call	0x1f1dc	; 0x1f1dc <gethex>
   1f73e:	18 2f       	mov	r17, r24
					addrl = gethex();
   1f740:	0e 94 ee f8 	call	0x1f1dc	; 0x1f1dc <gethex>
   1f744:	08 2f       	mov	r16, r24
					putch('=');
   1f746:	8d e3       	ldi	r24, 0x3D	; 61
   1f748:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					ch = *(uint8_t *)((addrh << 8) + addrl);
					puthex(ch);
   1f74c:	d1 2e       	mov	r13, r17
   1f74e:	cc 24       	eor	r12, r12
   1f750:	f6 01       	movw	r30, r12
   1f752:	e0 0f       	add	r30, r16
   1f754:	f1 1d       	adc	r31, r1
   1f756:	80 81       	ld	r24, Z
   1f758:	0e 94 79 f8 	call	0x1f0f2	; 0x1f0f2 <puthex>
   1f75c:	cb cf       	rjmp	.-106    	; 0x1f6f4 <block_done+0x156>
				}

				/* write a byte to address  */
				else if(ch == 'w') {
   1f75e:	17 37       	cpi	r17, 0x77	; 119
   1f760:	b9 f4       	brne	.+46     	; 0x1f790 <block_done+0x1f2>
					ch = getch(); putch(ch);
   1f762:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f766:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					addrh = gethex();
   1f76a:	0e 94 ee f8 	call	0x1f1dc	; 0x1f1dc <gethex>
   1f76e:	18 2f       	mov	r17, r24
					addrl = gethex();
   1f770:	0e 94 ee f8 	call	0x1f1dc	; 0x1f1dc <gethex>
   1f774:	08 2f       	mov	r16, r24
					ch = getch(); putch(ch);
   1f776:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f77a:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					ch = gethex();
   1f77e:	0e 94 ee f8 	call	0x1f1dc	; 0x1f1dc <gethex>
					*(uint8_t *)((addrh << 8) + addrl) = ch;
   1f782:	f1 2e       	mov	r15, r17
   1f784:	ee 24       	eor	r14, r14
   1f786:	f7 01       	movw	r30, r14
   1f788:	e0 0f       	add	r30, r16
   1f78a:	f1 1d       	adc	r31, r1
   1f78c:	80 83       	st	Z, r24
   1f78e:	b2 cf       	rjmp	.-156    	; 0x1f6f4 <block_done+0x156>
				}

				/* read from uart and echo back */
				else if(ch == 'u') {
   1f790:	15 37       	cpi	r17, 0x75	; 117
   1f792:	29 f4       	brne	.+10     	; 0x1f79e <block_done+0x200>
					for(;;) {
						putch(getch());
   1f794:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <getch>
   1f798:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
   1f79c:	fb cf       	rjmp	.-10     	; 0x1f794 <block_done+0x1f6>
					}
				}
#if defined(__AVR_ATmega128__) || defined(__AVR_ATmega1280__)
				/* external bus loop  */
				else if(ch == 'b') {
   1f79e:	12 36       	cpi	r17, 0x62	; 98
   1f7a0:	c9 f4       	brne	.+50     	; 0x1f7d4 <block_done+0x236>
					putch('b');
   1f7a2:	82 e6       	ldi	r24, 0x62	; 98
   1f7a4:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					putch('u');
   1f7a8:	85 e7       	ldi	r24, 0x75	; 117
   1f7aa:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					putch('s');
   1f7ae:	83 e7       	ldi	r24, 0x73	; 115
   1f7b0:	0e 94 67 f8 	call	0x1f0ce	; 0x1f0ce <putch>
					MCUCR = 0x80;
   1f7b4:	80 e8       	ldi	r24, 0x80	; 128
   1f7b6:	85 bf       	out	0x35, r24	; 53
					XMCRA = 0;
   1f7b8:	10 92 6d 00 	sts	0x006D, r1
					XMCRB = 0;
   1f7bc:	10 92 6c 00 	sts	0x006C, r1
   1f7c0:	e0 e0       	ldi	r30, 0x00	; 0
   1f7c2:	f1 e1       	ldi	r31, 0x11	; 17
   1f7c4:	cf 01       	movw	r24, r30
					extaddr = 0x1100;
					for(;;) {
						ch = *(volatile uint8_t *)extaddr;
   1f7c6:	fc 01       	movw	r30, r24
   1f7c8:	81 91       	ld	r24, Z+
						if(++extaddr == 0) {
   1f7ca:	80 e0       	ldi	r24, 0x00	; 0
   1f7cc:	91 e1       	ldi	r25, 0x11	; 17
   1f7ce:	30 97       	sbiw	r30, 0x00	; 0
   1f7d0:	c9 f7       	brne	.-14     	; 0x1f7c4 <block_done+0x226>
   1f7d2:	f9 cf       	rjmp	.-14     	; 0x1f7c6 <block_done+0x228>
						}
					}
				}
#endif

				else if(ch == 'j') {
   1f7d4:	1a 36       	cpi	r17, 0x6A	; 106
   1f7d6:	09 f0       	breq	.+2      	; 0x1f7da <block_done+0x23c>
   1f7d8:	8d cf       	rjmp	.-230    	; 0x1f6f4 <block_done+0x156>
					app_start();
   1f7da:	e0 91 04 01 	lds	r30, 0x0104
   1f7de:	f0 91 05 01 	lds	r31, 0x0105
   1f7e2:	09 95       	icall
   1f7e4:	87 cf       	rjmp	.-242    	; 0x1f6f4 <block_done+0x156>
		}
		}
	}
	/* end of monitor */
#endif
	else if (++error_count == MAX_ERROR_COUNT) {
   1f7e6:	80 91 03 01 	lds	r24, 0x0103
   1f7ea:	8f 5f       	subi	r24, 0xFF	; 255
   1f7ec:	80 93 03 01 	sts	0x0103, r24
   1f7f0:	85 30       	cpi	r24, 0x05	; 5
   1f7f2:	09 f0       	breq	.+2      	; 0x1f7f6 <block_done+0x258>
   1f7f4:	93 cd       	rjmp	.-1242   	; 0x1f31c <main+0x60>
		app_start();
   1f7f6:	e0 91 04 01 	lds	r30, 0x0104
   1f7fa:	f0 91 05 01 	lds	r31, 0x0105
   1f7fe:	09 95       	icall
   1f800:	8d cd       	rjmp	.-1254   	; 0x1f31c <main+0x60>

0001f802 <__eerd_byte_m128>:
   1f802:	e1 99       	sbic	0x1c, 1	; 28
   1f804:	fe cf       	rjmp	.-4      	; 0x1f802 <__eerd_byte_m128>
   1f806:	9f bb       	out	0x1f, r25	; 31
   1f808:	8e bb       	out	0x1e, r24	; 30
   1f80a:	e0 9a       	sbi	0x1c, 0	; 28
   1f80c:	99 27       	eor	r25, r25
   1f80e:	8d b3       	in	r24, 0x1d	; 29
   1f810:	08 95       	ret

0001f812 <__eewr_byte_m128>:
   1f812:	26 2f       	mov	r18, r22

0001f814 <__eewr_r18_m128>:
   1f814:	e1 99       	sbic	0x1c, 1	; 28
   1f816:	fe cf       	rjmp	.-4      	; 0x1f814 <__eewr_r18_m128>
   1f818:	9f bb       	out	0x1f, r25	; 31
   1f81a:	8e bb       	out	0x1e, r24	; 30
   1f81c:	2d bb       	out	0x1d, r18	; 29
   1f81e:	0f b6       	in	r0, 0x3f	; 63
   1f820:	f8 94       	cli
   1f822:	e2 9a       	sbi	0x1c, 2	; 28
   1f824:	e1 9a       	sbi	0x1c, 1	; 28
   1f826:	0f be       	out	0x3f, r0	; 63
   1f828:	01 96       	adiw	r24, 0x01	; 1
   1f82a:	08 95       	ret

0001f82c <_exit>:
   1f82c:	f8 94       	cli

0001f82e <__stop_program>:
   1f82e:	ff cf       	rjmp	.-2      	; 0x1f82e <__stop_program>
